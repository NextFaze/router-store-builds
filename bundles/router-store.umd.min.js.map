{"version":3,"sources":["../../../modules/router-store/src/router_store_module.ts"],"names":["routerReducer","state","action","type","ROUTER_NAVIGATION","ROUTER_ERROR","ROUTER_CANCEL","payload","routerState","navigationId","event","id","StoreRouterConnectingModule","store","router","this","dispatchTriggeredByRouter","navigationTriggeredByDispatch","setUpBeforePreactivationHook","setUpStoreStateListener","setUpStateRollbackEvents","prototype","_this","hooks","beforePreactivation","shouldDispatch","dispatchEvent","of","subscribe","s","storeState","navigateIfNeeded","lastRoutesRecognized","dispatch","url","navigateByUrl","events","e","RoutesRecognized","NavigationCancel","dispatchRouterCancel","NavigationError","dispatchRouterError","decorators","NgModule","args","ctorParameters","Store","Router"],"mappings":"mlBA8EA,SAAAA,eADCC,MAAAC,QAEC,OAAOA,OADQC,MAEb,IADKC,mBAEL,IADKC,cAEL,IADKC,eAEH,OADUL,MAAOC,OAAOK,QAAQC,YAAaC,aAAcP,OAAOK,QAAQG,MAAMC,GAElF,SACA,MADSV,QA7Eb,GACCG,mBAAA,oBAqBAE,cAAA,gBAsBAD,aAAA,cA+EDO,4BAAA,WAUA,QAAAA,6BADsBC,MAA2BC,QAA3BC,KAAtBF,MAAsBA,MAA2BE,KAAjDD,OAAiDA,OAPvCC,KAAVP,YAAoD,KAI1CO,KAAVC,2BAA+C,EACrCD,KAAVE,+BAAmD,EAK/CF,KAAKG,+BACLH,KAAKI,0BACLJ,KAAKK,iCACNR,6BAAHS,UAAAH,6BAAG,WAAA,GAAHI,OAAAP,IACUA,MAAM,OAAOQ,MAAMC,oBAAsB,SAAAhB,aAO7C,MAFAc,OAJKd,YAAcA,YAKfc,MAJKG,kBAAkBH,MAAKI,gBACzBC,mBAAAA,IAAG,KAIbf,4BAAHS,UAAAF,wBAAG,WAAA,GAAHG,OAAAP,IAOIA,MANKF,MAAMe,UAAU,SAAAC,GAOnBP,MANKQ,WAAaD,EAOlBP,MANKS,sBAIRnB,4BAAHS,UAAAK,cAAG,WASCX,KARKC,2BAA4B,CASjC,KACE,GARMT,UAAYC,YAAaO,KAAKP,YAAaE,MAAOK,KAAKiB,qBAS7DjB,MARKF,MAAMoB,UAAW9B,KAAMC,kBAAmBG,QAQrDA,kBAEMQ,KARKC,2BAA4B,EASjCD,KARKE,+BAAgC,IAIxCL,4BAAHS,UAAAI,eAAG,WAWC,OAVKV,KAAKe,WAAY,gBACff,KAAME,+BAGdL,4BAAHS,UAAAU,iBAAG,WACMhB,KAAKe,WAAY,gBAalBf,KAZKC,2BAcLD,KAZKD,OAAOoB,MAAQnB,KAAKe,WAAY,cAAgB7B,MAAMiC,MAa7DnB,KAZKE,+BAAgC,EAarCF,KAZKD,OAAOqB,cAAcpB,KAAKe,WAAY,cAAgB7B,MAAMiC,QAIpEtB,4BAAHS,UAAAD,yBAAG,WAAA,GAAHE,OAAAP,IAeIA,MAdKD,OAAOsB,OAAOR,UAAU,SAAAS,GAevBA,YAdaC,iBAAAA,iBAefhB,MAdKU,qBAAuBK,EACvBA,YAAiBE,iBAAAA,iBAetBjB,MAdKkB,qBAAqBH,GACrBA,YAAiBI,iBAAAA,iBAetBnB,MAdKoB,oBAAoBL,MAK9BzB,4BAAHS,UAAAmB,qBAAG,SAAA9B,OAkBC,GAjBMH,UAAYC,YAAaO,KAAKP,YAAasB,WAAYf,KAAKe,WAAYpB,MAiBlFA,MACIK,MAjBKF,MAAMoB,UAAW9B,KAAMG,cAAeC,QAiB/CA,WAdGK,4BAAHS,UAAAqB,oBAAG,SAAAhC,OAqBC,GApBMH,UAAYC,YAAaO,KAAKP,YAAasB,WAAYf,KAAKe,WAAYpB,MAoBlFA,MACIK,MApBKF,MAAMoB,UAAW9B,KAAME,aAAcE,QAoB9CA,yCAlBOK,6BAAP+B,aACExC,KAAMyC,cAAAA,SAAUC,YAGjBjC,4BAADkC,eAAC,WAAA,QAuBA3C,KAAM4C,YAAAA,QACN5C,KAAM6C,gBAAAA","file":"./dist/router-store/bundles/router-store.umd.min.js","sourcesContent":["import {NgModule} from '@angular/core';\nimport {NavigationCancel, NavigationError, Router, RouterStateSnapshot, RoutesRecognized} from '@angular/router';\nimport {Store} from '@ngrx/store';\nimport {of} from 'rxjs/observable/of';\n/**\n * An action dispatched when the router navigates.\n */\nexport const ROUTER_NAVIGATION = 'ROUTER_NAVIGATION';\n\n/**\n * Payload of ROUTER_NAVIGATION.\n */\nexport type RouterNavigationPayload = {\n  routerState: RouterStateSnapshot,\n  event: RoutesRecognized\n};\n\n/**\n * An action dispatched when the router navigates.\n */\nexport type RouterNavigationAction = {\n  type: typeof ROUTER_NAVIGATION,\n  payload: RouterNavigationPayload\n};\n/**\n * An action dispatched when the router cancels navigation.\n */\nexport const ROUTER_CANCEL = 'ROUTER_CANCEL';\n\n/**\n * Payload of ROUTER_CANCEL.\n */\nexport type RouterCancelPayload<T> = {\n  routerState: RouterStateSnapshot,\n  storeState: T,\n  event: NavigationCancel\n};\n\n/**\n * An action dispatched when the router cancel navigation.\n */\nexport type RouterCancelAction<T> = {\n  type: typeof ROUTER_CANCEL,\n  payload: RouterCancelPayload<T>\n};\n/**\n * An action dispatched when the router errors.\n */\nexport const ROUTER_ERROR = 'ROUTE_ERROR';\n\n/**\n * Payload of ROUTER_ERROR.\n */\nexport type RouterErrorPayload<T> = {\n  routerState: RouterStateSnapshot,\n  storeState: T,\n  event: NavigationError\n};\n\n/**\n * An action dispatched when the router errors.\n */\nexport type RouterErrorAction<T> = {\n  type: typeof ROUTER_ERROR,\n  payload: RouterErrorPayload<T>\n};\n\n/**\n * An union type of router actions.\n */\nexport type RouterAction<T> = RouterNavigationAction | RouterCancelAction<T> | RouterErrorAction<T>;\n\nexport type RouterReducerState = { state: RouterStateSnapshot, navigationId: number };\n/**\n * @param {?} state\n * @param {?} action\n * @return {?}\n */\nexport function routerReducer(state: RouterReducerState, action: RouterAction<any>): RouterReducerState {\n  switch (action.type) {\n    case ROUTER_NAVIGATION:\n    case ROUTER_ERROR:\n    case ROUTER_CANCEL:\n      return ({ state: action.payload.routerState, navigationId: action.payload.event.id });\n    default:\n      return state;\n  }\n}\n/**\n * Connects RouterModule with StoreModule.\n * \n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n * \n * ```\n * export type RouterNavigationPayload = {\n *   routerState: RouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n * \n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n * \n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n * \n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n * \n * Usage:\n * \n * ```typescript\n * \\@NgModule({ \n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.provideStore(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\nexport class StoreRouterConnectingModule {\nprivate routerState: RouterStateSnapshot | null = null;\nprivate storeState: any;\nprivate lastRoutesRecognized: RoutesRecognized;\nprivate dispatchTriggeredByRouter: boolean = false;\nprivate navigationTriggeredByDispatch: boolean = false;\n/**\n * @param {?} store\n * @param {?} router\n */\nconstructor(private store: Store<any>,\nprivate router: Router) {\n    this.setUpBeforePreactivationHook();\n    this.setUpStoreStateListener();\n    this.setUpStateRollbackEvents();\n  }\n/**\n * @return {?}\n */\nprivate setUpBeforePreactivationHook(): void {\n    ( /** @type {?} */((<any>this.router))).hooks.beforePreactivation = (routerState: RouterStateSnapshot) => {\n      this.routerState = routerState;\n      if (this.shouldDispatch()) this.dispatchEvent();\n      return of(true);\n    };\n  }\n/**\n * @return {?}\n */\nprivate setUpStoreStateListener(): void {\n    this.store.subscribe(s => {\n      this.storeState = s;\n      this.navigateIfNeeded();\n    });\n  }\n/**\n * @return {?}\n */\nprivate dispatchEvent(): void {\n    this.dispatchTriggeredByRouter = true;\n    try {\n      const /** @type {?} */ payload = { routerState: this.routerState, event: this.lastRoutesRecognized };\n      this.store.dispatch({ type: ROUTER_NAVIGATION, payload });\n    } finally {\n      this.dispatchTriggeredByRouter = false;\n      this.navigationTriggeredByDispatch = false;\n    }\n  }\n/**\n * @return {?}\n */\nprivate shouldDispatch(): boolean {\n    if (!this.storeState['routerReducer']) return true;\n    return !this.navigationTriggeredByDispatch;\n  }\n/**\n * @return {?}\n */\nprivate navigateIfNeeded(): void {\n    if (!this.storeState['routerReducer']) return;\n    if (this.dispatchTriggeredByRouter) return;\n\n    if (this.router.url !== this.storeState['routerReducer'].state.url) {\n      this.navigationTriggeredByDispatch = true;\n      this.router.navigateByUrl(this.storeState['routerReducer'].state.url);\n    }\n  }\n/**\n * @return {?}\n */\nprivate setUpStateRollbackEvents(): void {\n    this.router.events.subscribe(e => {\n      if (e instanceof RoutesRecognized) {\n        this.lastRoutesRecognized = e;\n      } else if (e instanceof NavigationCancel) {\n        this.dispatchRouterCancel(e);\n      } else if (e instanceof NavigationError) {\n        this.dispatchRouterError(e);\n      }\n    });\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nprivate dispatchRouterCancel(event: NavigationCancel): void {\n    const /** @type {?} */ payload = { routerState: this.routerState, storeState: this.storeState, event };\n    this.store.dispatch({ type: ROUTER_CANCEL, payload });\n  }\n/**\n * @param {?} event\n * @return {?}\n */\nprivate dispatchRouterError(event: NavigationError): void {\n    const /** @type {?} */ payload = { routerState: this.routerState, storeState: this.storeState, event };\n    this.store.dispatch({ type: ROUTER_ERROR, payload });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Store, },\n{type: Router, },\n];\n}\n\nfunction StoreRouterConnectingModule_tsickle_Closure_declarations() {\n/** @type {?} */\nStoreRouterConnectingModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nStoreRouterConnectingModule.ctorParameters;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.routerState;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.storeState;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.lastRoutesRecognized;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.dispatchTriggeredByRouter;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.navigationTriggeredByDispatch;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.store;\n/** @type {?} */\nStoreRouterConnectingModule.prototype.router;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}